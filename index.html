<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>AX/AO CPT Practice (Mobile)</title>

    <!-- Allow free zoom and scroll -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes"
    />

    <!-- jsPsych core & button plugin -->
    <script src="dist/jspsych.js"></script>
    <script src="dist/plugin-html-button-response.js"></script>
    <link rel="stylesheet" href="../dist/jspsych.css" />
    
    <style>
      :root {
        /* Vertical offset (in px) for all jsPsych stimuli after fixation calibration */
        --fixation-offset-y: 0px;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
        background: #fafafa;
        margin: 0;
      }

      /* jsPsych content center + apply vertical offset */
      #jspsych-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 16px;
        text-align: center;
        transform: translateY(var(--fixation-offset-y));
        box-sizing: border-box;
      }

      .big {
        font-size: clamp(32px, 10vmin, 72px);
        letter-spacing: 2px;
        color: #000;
      }

      .jspsych-btn {
        width: min(32vw, 180px);
        padding: 10px 0;
        font-size: clamp(14px, 2.4vmin, 18px);
        border-radius: 8px;
        border: 1px solid #333;
        background: #fff;
        margin: 0;
      }

      .jspsych-btn:active {
        transform: scale(0.97);
      }

      .start-btn {
        width: min(70vw, 260px);
        padding: 14px 0;
        font-size: clamp(16px, 2.6vmin, 20px);
        border-radius: 999px;
        border: 1px solid #333;
        background: #fff;
      }

      .start-btn:active {
        transform: scale(0.97);
      }

      /* Fixed bottom button group (jsPsych response buttons) */
      #jspsych-html-button-response-btngroup {
        position: fixed;
        left: 50%;
        bottom: 6vh;
        transform: translateX(-50%);
        display: flex;
        gap: 32px;
        z-index: 1000;
      }

      /* Orientation suggestion overlay (portrait only) */
      #orientation_warning {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        z-index: 9999;
        padding: 16px;
        box-sizing: border-box;
        pointer-events: none;
      }

      @media screen and (orientation: landscape) {
        #orientation_warning {
          display: none !important;
        }
      }

      /* Instruction screen: allow scroll & zoom */
      #start_screen {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        min-height: 100vh;          /* use min-height so scrolling is possible */
        padding: 16px;
        padding-top: 8vh;
        text-align: center;
        box-sizing: border-box;
      }

      /* === NEW: fixation calibration screen ===
         Structure:
         - Full-screen container
         - Text overlay (fixed) on top
         - Underneath: a scrollable "+ layer" filling the whole viewport
         - Scrolling only moves the "+" layer; the text remains still
      */
      #fixation_screen {
        display: none;
        position: relative;
        height: 100vh;
        overflow: hidden; /* keep everything inside the viewport */
        background: #fafafa;
      }

      /* Text overlay that stays fixed while the "+" layer scrolls */
      #fixation_text_overlay {
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        padding: 12px 16px;
        box-sizing: border-box;
        z-index: 10;
        pointer-events: none; /* allow scroll/zoom to pass through by default */
      }

      #fixation_text_overlay_inner {
        max-width: 460px;
        margin: 0 auto;
        background: rgba(250, 250, 250, 0.95);
        border-radius: 12px;
        padding: 12px 16px 16px 16px;
        box-sizing: border-box;
        pointer-events: auto; /* interactive (button clickable) */
        text-align: center;
      }

      /* Scrollable "+" layer, full-screen */
      #fixation_viewport {
        position: absolute;
        inset: 0;
        overflow-y: scroll;                 /* scroll only moves this layer */
        -webkit-overflow-scrolling: touch;  /* smooth scrolling on iOS */
        z-index: 1;
      }

      /* A tall "world" so that the "+" can move vertically when scrolling */
      #fixation_world {
        height: 300vh; /* taller than one screen to allow movement */
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #fixation_plus {
        /* Same class as stimuli: visual size consistent */
      }

      #fixation_start_btn {
        position: fixed;
        left: 50%;
        bottom: 40px;              /* 距离屏幕底部 40px，可以自己调 */
        transform: translateX(-50%);
        z-index: 20;               /* 比 + 层高一点，保证能点 */
      }
      
            /* Center calibration crosshair */
      #fixation_center_hline,
      #fixation_center_vline {
        position: fixed;
        z-index: 5;      /* higher than + layer, lower than text overlay */
        pointer-events: none;   /* user can still scroll and click normally */
      }

      /* Horizontal dashed line across center */
      #fixation_center_hline {
        top: 50%;
        left: 0;
        width: 100%;
        border-top: 1px dashed rgba(0,0,0,0.35);
        transform: translateY(-0.5px); /* perfect alignment */
      }

      /* Vertical dashed line across center */
      #fixation_center_vline {
        left: 50%;
        top: 0;
        height: 100%;
        border-left: 1px dashed rgba(0,0,0,0.35);
        transform: translateX(-2px);
      }

    </style>
  </head>

  <body>
    <!-- Instruction: free scroll & zoom allowed -->
    <div id="start_screen">
      <h2>连续性操作测验 - 练习</h2>
      <p style="max-width:420px;line-height:1.6;">
        本阶段为 <b>40 次练习</b>，用于熟悉节奏。
      </p>
      <p style="max-width:420px;line-height:1.6;text-align:left;">
        规则：<br/>
        · A→X → 点击左侧按钮（A-X）<br/>
        · A→O → 点击右侧按钮（A-O）<br/>
        · 其他情况不要点。
      </p>

      <p style="max-width:420px; line-height:1.6; font-size:14px; color:#555;">
        在本页和下一页，你都可以自由缩放或滑动屏幕，<br/>
        找到一个你觉得舒适的观看方式。
      </p>

      <button id="start_btn" class="start-btn">下一步：调整注视点位置</button>
    </div>

    <!-- NEW: fixation calibration screen -->
    <div id="fixation_screen">
      <!-- Center crosshair lines -->
      <div id="fixation_center_hline"></div>
      <div id="fixation_center_vline"></div>
      <!-- Text overlay -->
      <div id="fixation_text_overlay">
        <div id="fixation_text_overlay_inner">
          <p style="margin:0; line-height:1.6;">
            中间这一个 <span style="font-weight:bold;">“+”</span> 将在正式练习中作为注视点。
          </p>
          <p style="text-align:center; margin:12px 0;">
            请上下滑动屏幕，把 “+” 调整到<strong>最居中的位置</strong>
          </p>
          <p style="margin:0 0 8px 0; line-height:1.6; font-size:13px; color:#555;">
            调整好后，请尽量保持手机和头部姿势不变，<br/>
            点击下面的按钮开始正式练习。
          </p>
          <button id="fixation_start_btn" class="start-btn">
            我已经调整好了，开始练习
          </button>
        </div>
      </div>

      <!-- Scrollable "+" layer -->
      <div id="fixation_viewport">
        <div id="fixation_world">
          <div id="fixation_plus" class="big">+</div>
        </div>
      </div>
    </div>

    <!-- Orientation suggestion overlay (portrait only) -->
    <div id="orientation_warning">
      <div>
        <h2>建议横屏使用</h2>
        <p>为了更好的任务体验，请将手机横屏。</p>
      </div>
    </div>
  </body>

  <script>
    const jsPsych = initJsPsych({
      on_finish: function () {
        const trials = jsPsych.data.get().filter({ task: "cpt_practice" }).values();

        const nTarget = trials.filter((t) => t.is_target).length;
        const nNon = trials.length - nTarget;

        const omissions = trials.filter((t) => t.is_target && !t.responded).length;
        const commissions = trials.filter((t) => !t.is_target && t.responded).length;

        const hits = trials.filter(
          (t) => t.is_target && t.correct && Number.isFinite(t.rt)
        );
        const rtList = hits.map((t) => t.rt);
        const meanRT = rtList.length ? Math.round(rtList.reduce((a, b) => a + b) / rtList.length) : "-";

        document.body.innerHTML = `
        <div id="jspsych-content" style="gap:12px;">
          <h2>练习结束</h2>
          <div>目标试次：${nTarget}</div>
          <div>非目标试次：${nNon}</div>
          <div>遗漏：${omissions}</div>
          <div>误报：${commissions}</div>
          <div>平均反应时（正确目标）：${meanRT} ms</div>
          <button id="dl" class="jspsych-btn">下载结果</button>
        </div>`;

        document.getElementById("dl").addEventListener("click", () => {
          jsPsych.data.get().localSave("csv", "practice_result.csv");
        });
      }
    });

    const plugin_button = window.jsPsychHtmlButtonResponse;

    // === Parameters ===
    const N_TRIALS = 40;
    const N_AX = 4;
    const N_AO = 4;

    const LETTER_MS = 300;
    const ITI_MS = 900;
    const TOTAL_WINDOW = LETTER_MS + ITI_MS;
    const FEEDBACK_MS = 300;

    const DIST = "BCDEFGHIJKLXO".split("");

    function randChoice(a) {
      return a[Math.floor(Math.random() * a.length)];
    }

    function makePractice() {
      const blocks = [];
      for (let i = 0; i < N_AX; i++) blocks.push({ letters: ["A", "X"], type: "AX" });
      for (let i = 0; i < N_AO; i++) blocks.push({ letters: ["A", "O"], type: "AO" });

      const remain = N_TRIALS - (N_AX + N_AO) * 2;
      for (let i = 0; i < remain; i++)
        blocks.push({ letters: [randChoice(DIST)], type: null });

      // Shuffle blocks
      for (let i = blocks.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [blocks[i], blocks[j]] = [blocks[j], blocks[i]];
      }

      const trials = [];
      blocks.forEach((b) => {
        if (b.type === "AX" || b.type === "AO") {
          trials.push({ letter: "A", is_target: false, target_type: null });
          trials.push({ letter: b.letters[1], is_target: true, target_type: b.type });
        } else {
          trials.push({ letter: b.letters[0], is_target: false, target_type: null });
        }
      });

      return trials;
    }

    const practiceTrials = makePractice();
    const timeline = [];

    // === Error instruction node (shown only after incorrect responses) ===
    const error_instruction_node = {
      timeline: [
        {
          type: plugin_button,
          stimulus: function () {
            const last = jsPsych.data.get().filter({ task: "cpt_practice" }).last(1).values()[0];

            // Determine error type
            let errorMsg = "";
            if (last.is_target && !last.responded) {
              // Miss on target trial
              errorMsg = `<p style="color:#d00; font-weight:bold;">你错过了需要反应的试次。</p>`;
            } else if (!last.is_target && last.responded) {
              // Commission on non-target
              errorMsg = `<p style="color:#d00; font-weight:bold;">这不是需要反应的试次，你不应该按键。</p>`;
            } else if (last.is_target && last.responded && !last.correct) {
              // Wrong button on AX/AO
              errorMsg = `<p style="color:#d00; font-weight:bold;">你按错了按钮。</p>`;
            } else {
              // fallback
              errorMsg = `<p style="color:#d00; font-weight:bold;">请注意反应。</p>`;
            }

            return `
              <div style="max-width:420px; margin:0 auto; text-align:left; line-height:1.8;">
                ${errorMsg}
                <p>请注意反应规则</p>
                <ul style="text-align:left; padding-left:20px;">
                  <li>A 后面出现 <strong>X</strong>：点击左侧按钮（A-X）</li>
                  <li>A 后面出现 <strong>O</strong>：点击右侧按钮（A-O）</li>
                  <li>其他情况<strong>无需点击任何按钮</strong></li>
                  <li>请尽可能又快又准的做出反应</li>
                </ul>
              </div>
            `;
          },
          choices: ["继续实验"],
          data: { task: "error_instruction" },
        },
      ],

      conditional_function: function () {
        const lastPractice = jsPsych.data.get().filter({ task: "cpt_practice" }).last(1).values()[0];
        return lastPractice && lastPractice.correct === false;
      },
    };


    practiceTrials.forEach((t) => {
      // 1) main trial
      timeline.push({
        type: plugin_button,
        stimulus: `<div class="big">${t.letter}</div>`,
        choices: ["左：A-X", "右：A-O"],
        trial_duration: TOTAL_WINDOW,
        data: {
          task: "cpt_practice",
          letter: t.letter,
          is_target: t.is_target,
          target_type: t.target_type,
        },
        on_load: function () {
          const stim = document.getElementById("jspsych-html-button-response-stimulus");
          setTimeout(() => {
            if (stim) stim.innerHTML = `<div class="big">+</div>`;
          }, LETTER_MS);
        },
        on_finish: function (d) {
          const r = d.response;
          d.responded = r !== null;

          let correct = false;
          if (d.is_target) {
            correct = (d.target_type === "AX" && r === 0) || (d.target_type === "AO" && r === 1);
          } else {
            correct = !d.responded;
          }
          d.correct = correct;
        },
      });

      // 2) feedback: colored "+"
      timeline.push({
        type: plugin_button,
        stimulus: function () {
          const last = jsPsych.data.get().last(1).values()[0];

          let color = "#000";
          if (last.is_target) color = last.correct ? "green" : "red";
          else if (last.responded) color = "red";

          return `<div class="big" style="color:${color};">+</div>`;
        },
        choices: ["左：A-X", "右：A-O"],
        response_ends_trial: false,
        trial_duration: FEEDBACK_MS,
        data: { task: "feedback" },
      });

      // 3) conditional error-instruction screen
      timeline.push(error_instruction_node);
    });

    // === Instruction → Fixation screen ===
    document.getElementById("start_btn").addEventListener("click", () => {
      document.getElementById("start_screen").style.display = "none";
      const fs = document.getElementById("fixation_screen");
      fs.style.display = "block";

      // Initialize the scroll position roughly to center of the world
      const viewport = document.getElementById("fixation_viewport");
      const world = document.getElementById("fixation_world");
      // Use a timeout to ensure layout is ready
      setTimeout(() => {
        const extra = world.scrollHeight - viewport.clientHeight;
        if (extra > 0) {
          viewport.scrollTop = extra / 2;
        }
      }, 50);
    });

    // === Fixation calibration → jsPsych practice ===
    document.getElementById("fixation_start_btn").addEventListener("click", () => {
      const viewport = document.getElementById("fixation_viewport");
      const world = document.getElementById("fixation_world");

      const scrollTop = viewport.scrollTop;
      const worldHeight = world.scrollHeight;
      const screenHeight = viewport.clientHeight;

      // Center of "+" in the "world" coordinate
      const plusCenterWorldY = worldHeight / 2;

      // Where is the "+" on the screen now?
      const plusCenterOnScreen = plusCenterWorldY - scrollTop;

      // Default jsPsych center is screenHeight / 2.
      // Compute offset so that jsPsych stimuli will appear at the same vertical position.
      const offsetY = plusCenterOnScreen - screenHeight / 2;

      // Apply offset to :root CSS variable
      document.documentElement.style.setProperty("--fixation-offset-y", `${offsetY}px`);

      // Hide fixation screen and start jsPsych
      document.getElementById("fixation_screen").style.display = "none";
      jsPsych.run(timeline);
    });
  </script>
</html>
